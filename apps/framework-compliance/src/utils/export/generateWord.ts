/**
 * Word Document Generation Utility
 * Uses docx library to create professional Word documents
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';

export interface WordDocumentData {
  title: string;
  subtitle?: string;
  metadata?: {
    generatedAt?: string;
    generatedBy?: string;
    version?: string;
    organization?: string;
  };
  sections?: Array<{
    title: string;
    content: string | string[];
    level?: typeof HeadingLevel[keyof typeof HeadingLevel];
  }>;
  tables?: Array<{
    title?: string;
    headers: string[];
    rows: Array<Array<string | number>>;
  }>;
  summary?: Record<string, string | number>;
}

/**
 * Generate a Word document from structured data
 */
export async function generateWordDocument(
  data: WordDocumentData,
  filename?: string
): Promise<void> {
  try {
    const children: (Paragraph | Table)[] = [];

    // Title
    children.push(
      new Paragraph({
        text: data.title,
        heading: HeadingLevel.TITLE,
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      })
    );

    // Subtitle
    if (data.subtitle) {
      children.push(
        new Paragraph({
          text: data.subtitle,
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          spacing: { after: 300 },
        })
      );
    }

    // Metadata
    if (data.metadata) {
      const metadataText: (TextRun | string)[] = [];
      if (data.metadata.generatedAt) {
        metadataText.push(new TextRun({ text: `Generated: ${data.metadata.generatedAt}`, break: 1 }));
      }
      if (data.metadata.generatedBy) {
        metadataText.push(new TextRun({ text: `Generated by: ${data.metadata.generatedBy}`, break: 1 }));
      }
      if (data.metadata.organization) {
        metadataText.push(new TextRun({ text: `Organization: ${data.metadata.organization}`, break: 1 }));
      }
      if (data.metadata.version) {
        metadataText.push(new TextRun({ text: `Version: ${data.metadata.version}`, break: 1 }));
      }

      if (metadataText.length > 0) {
        children.push(
          new Paragraph({
            children: metadataText as TextRun[],
            spacing: { after: 400 },
          })
        );
      }
    }

    // Summary
    if (data.summary) {
      children.push(
        new Paragraph({
          text: 'Summary',
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 200, after: 200 },
        })
      );

      const summaryRows: TableRow[] = [];
      Object.entries(data.summary).forEach(([key, value]) => {
        summaryRows.push(
          new TableRow({
            children: [
              new TableCell({
                children: [new Paragraph({ text: key, alignment: AlignmentType.LEFT })],
                width: { size: 50, type: WidthType.PERCENTAGE },
              }),
              new TableCell({
                children: [new Paragraph({ text: String(value), alignment: AlignmentType.LEFT })],
                width: { size: 50, type: WidthType.PERCENTAGE },
              }),
            ],
          })
        );
      });

      if (summaryRows.length > 0) {
        children.push(
          new Table({
            rows: summaryRows,
            width: { size: 100, type: WidthType.PERCENTAGE },
          })
        );
      }
    }

    // Sections
    if (data.sections) {
      data.sections.forEach((section) => {
        children.push(
          new Paragraph({
            text: section.title,
            heading: section.level || HeadingLevel.HEADING_1,
            spacing: { before: 300, after: 200 },
          })
        );

        const content = Array.isArray(section.content) ? section.content : [section.content];
        content.forEach((item) => {
          children.push(
            new Paragraph({
              text: item,
              spacing: { after: 100 },
            })
          );
        });
      });
    }

    // Tables
    if (data.tables) {
      data.tables.forEach((table) => {
        if (table.title) {
          children.push(
            new Paragraph({
              text: table.title,
              heading: HeadingLevel.HEADING_2,
              spacing: { before: 300, after: 200 },
            })
          );
        }

        const tableRows: TableRow[] = [];

        // Header row
        tableRows.push(
          new TableRow({
            children: table.headers.map((header) =>
              new TableCell({
                children: [
                  new Paragraph({
                    text: header,
                    alignment: AlignmentType.LEFT,
                  }),
                ],
              })
            ),
          })
        );

        // Data rows
        table.rows.forEach((row) => {
          tableRows.push(
            new TableRow({
              children: row.map((cell) =>
                new TableCell({
                  children: [
                    new Paragraph({
                      text: String(cell),
                      alignment: AlignmentType.LEFT,
                    }),
                  ],
                })
              ),
            })
          );
        });

        children.push(
          new Table({
            rows: tableRows,
            width: { size: 100, type: WidthType.PERCENTAGE },
          })
        );
      });
    }

    // Create document
    const doc = new Document({
      sections: [
        {
          children,
        },
      ],
    });

    // Generate and download
    const blob = await Packer.toBlob(doc);
    const finalFilename = filename || `${data.title.replace(/\s+/g, '-').toLowerCase()}-${new Date().toISOString().split('T')[0]}.docx`;
    saveAs(blob, finalFilename);
  } catch (error) {
    console.error('Error generating Word document:', error);
    throw new Error('Failed to generate Word document');
  }
}

/**
 * Generate Word document from report data
 */
export async function generateReportWord(
  reportData: {
    title: string;
    summary?: Record<string, string | number>;
    recommendations?: Array<{
      priority: string;
      title: string;
      timeframe: string;
      description?: string;
    }>;
    metadata?: {
      generatedAt?: string;
      generatedBy?: string;
    };
  },
  filename?: string
): Promise<void> {
  const wordData: WordDocumentData = {
    title: reportData.title,
    metadata: reportData.metadata,
    summary: reportData.summary,
    sections: reportData.recommendations?.map((rec) => ({
      title: `${rec.priority}: ${rec.title}`,
      content: [
        rec.description || '',
        `Timeframe: ${rec.timeframe}`,
      ].filter(Boolean),
      level: HeadingLevel.HEADING_2,
    })),
  };

  return generateWordDocument(wordData, filename);
}

